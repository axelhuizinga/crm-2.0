<?php
/**
 * Generated by Haxe 4.1.1
 * Haxe source file: /opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx
 */

namespace jwt;

use \php\_Boot\HxAnon;
use \haxe\io\_BytesData\Container;
use \php\Boot;
use \haxe\Exception;
use \haxe\Json;
use \php\_Boot\HxString;
use \haxe\crypto\HashMethod;
use \haxe\crypto\Hmac;
use \haxe\io\Bytes;

/**
 * All JWT functionality is implemented here (namely signing and verifying tokens)
 */
class JWT {
	/**
	 * @param string $s
	 * 
	 * @return Bytes
	 */
	public static function base64url_decode ($s) {
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:43: characters 9-57
		$s64 = \StringTools::replace(\StringTools::replace($s, "-", "+"), "_", "/");
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:44: lines 44-50
		$s641 = null;
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:44: characters 23-37
		$__hx__switch = (mb_strlen($s64) % 4);
		if ($__hx__switch === 0) {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:44: lines 44-50
			$s641 = "";
		} else if ($__hx__switch === 1) {
			$s641 = "===";
		} else if ($__hx__switch === 2) {
			$s641 = "==";
		} else if ($__hx__switch === 3) {
			$s641 = "=";
		} else {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:49: characters 21-26
			throw Exception::thrown("Illegal base64url string!");
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:51: characters 16-34
		$str = $s64 = ($s64??'null') . ($s641??'null');
		$s = base64_decode($str, true);
		$tmp = strlen($s);
		return new Bytes($tmp, new Container($s));
	}

	/**
	 * @param Bytes $b
	 * 
	 * @return string
	 */
	public static function base64url_encode ($b) {
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:38: characters 26-42
		$result = base64_encode($b->toString());
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:38: characters 9-43
		$b64 = $result;
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:39: characters 9-72
		return \StringTools::replace(\StringTools::replace(\StringTools::replace($b64, "+", "-"), "/", "_"), "=", "");
	}

	/**
	 * Extracts the payload from a JWT, throwing an exception if it is malformed
	 * @param jwt - The token to extract from
	 * @return T
	 * 
	 * @param string $jwt
	 * 
	 * @return mixed
	 */
	public static function extract ($jwt) {
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:131: characters 9-50
		$parts = HxString::split($jwt, ".");
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:132: characters 9-36
		if ($parts->length !== 3) {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:132: characters 31-36
			throw Exception::thrown("Malformed JWT!");
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:133: characters 16-65
		return Json::phpJsonDecode(JWT::base64url_decode(($parts->arr[1] ?? null))->toString());
	}

	/**
	 * Creates a signed JWT
	 * @param header - header information. If null, will default to HS256 encryption
	 * @param payload - The data to include
	 * @param replacer -  If `replacer` is given and is not null, it is used to retrieve the
	 * actual payload to be encoded. The `replacer` function takes two parameters,
	 * the key and the value being encoded. Initial key value is an empty string.
	 * @see <http://api.haxe.org/haxe/Json.html#stringify>
	 * @param secret - The secret to generate the signature with
	 * @return String
	 * 
	 * @param mixed $payload
	 * @param string $secret
	 * @param \Closure $replacer
	 * @param object $header
	 * 
	 * @return string
	 */
	public static function sign ($payload, $secret, $replacer = null, $header = null) {
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:74: lines 74-79
		if ($header === null) {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:75: lines 75-78
			$header = new HxAnon([
				"alg" => "HS256",
				"typ" => "JWT",
			]);
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:82: characters 9-40
		$header->alg = "HS256";
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:84: characters 9-47
		$h = Json::phpJsonEncode($header, null, null);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:85: characters 9-58
		$p = Json::phpJsonEncode($payload, $replacer, null);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:86: characters 44-61
		$hb64 = strlen($h);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:86: characters 9-63
		$hb641 = JWT::base64url_encode(new Bytes($hb64, new Container($h)));
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:87: characters 44-61
		$pb64 = strlen($p);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:87: characters 9-63
		$pb641 = JWT::base64url_encode(new Bytes($pb64, new Container($p)));
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:88: lines 88-91
		$sb = null;
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:88: characters 31-41
		if ($header->alg === "HS256") {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:88: lines 88-91
			$sb = JWT::signature($header->alg, ($hb641??'null') . "." . ($pb641??'null'), $secret);
		} else {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:90: characters 22-27
			throw Exception::thrown("The " . ($header->alg??'null') . " algorithm isn't supported yet!");
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:92: characters 9-45
		$s = JWT::base64url_encode($sb);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:94: characters 9-43
		return ($hb641??'null') . "." . ($pb641??'null') . "." . ($s??'null');
	}

	/**
	 * @param string $alg
	 * @param string $body
	 * @param string $secret
	 * 
	 * @return Bytes
	 */
	public static function signature ($alg, $body, $secret) {
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:55: characters 9-44
		if ($alg !== "HS256") {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:55: characters 39-44
			throw Exception::thrown("HS256 is the only supported algorithm for now!");
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:57: characters 9-53
		$hmac = new Hmac(HashMethod::SHA256());
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:58: characters 34-56
		$sb = strlen($secret);
		$sb1 = new Bytes($sb, new Container($secret));
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:58: characters 58-78
		$sb = strlen($body);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:58: characters 9-80
		$sb2 = $hmac->make($sb1, new Bytes($sb, new Container($body)));
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:59: characters 9-18
		return $sb2;
	}

	/**
	 * Verifies a JWT and returns the payload if successful
	 * @param jwt - the token to examine
	 * @param secret - the secret to compare it with
	 * @return JWTResult<T>
	 * 
	 * @param string $jwt
	 * @param string $secret
	 * 
	 * @return JWTResult
	 */
	public static function verify ($jwt, $secret) {
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:106: characters 9-50
		$parts = HxString::split($jwt, ".");
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:107: characters 9-57
		if ($parts->length !== 3) {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:107: characters 31-57
			return JWTResult::Malformed();
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:109: characters 9-62
		$h = JWT::base64url_decode(($parts->arr[0] ?? null))->toString();
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:110: characters 9-52
		$header = Json::phpJsonDecode($h);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:111: characters 9-51
		if ($header->alg !== "HS256") {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:111: characters 46-51
			throw Exception::thrown("The " . ($header->alg??'null') . " algorithm isn't supported yet!");
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:113: characters 9-62
		$p = JWT::base64url_decode(($parts->arr[1] ?? null))->toString();
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:116: characters 9-51
		$sb = JWT::base64url_decode(($parts->arr[2] ?? null));
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:117: characters 9-86
		$testSig = JWT::signature($header->alg, (($parts->arr[0] ?? null)??'null') . "." . (($parts->arr[1] ?? null)??'null'), $secret);
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:118: characters 9-77
		if (($sb->b->s <=> $testSig->b->s) !== 0) {
			#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:118: characters 38-77
			return JWTResult::Invalid(Json::phpJsonDecode($p));
		}
		#/opt/src/crm-2.0/server/.haxelib/jwt/1,3,0/src/jwt/JWT.hx:122: characters 9-46
		return JWTResult::Valid(Json::phpJsonDecode($p));
	}

	/**
	 * @return void
	 */
	public function __construct () {
	}
}

Boot::registerClass(JWT::class, 'jwt.JWT');
